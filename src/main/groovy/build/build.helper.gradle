def prefix(msg) {
	return "[TEST]" + msg
}
def info(msg) {
	project.logger.info(prefix(msg))
}
def debug(msg) {
	project.logger.debug(prefix(msg))
}

info("Script inclusion")

configurations {
	all {
		resolutionStrategy {
	           dependencySubstitution.all { DependencySubstitution dependency ->

			if ( dependency.requested instanceof ModuleComponentSelector ) {			

				if ( buildFromLocal instanceof String ) {

				   // tweak remote dependencie resolution
				   if ( requested.group == "com.github.ReleaseStandard" ) {

					def modPath = ":" + requested.getModule()
					def module = rootProject.findProject(modPath)
					if ( module == null ) {
						println "[ERROR] " + modPath + " not found"
					}

					//
					def modCount = 0
					module.subprojects { Project p ->
						modCount = modCount + 1
					}
					if ( modCount == 1 ) {
						println "Module alone : in " + modPath
						module.subprojects { Project p ->
							dependency.useTarget p
						}
					} else if ( modCount > 1 ) {
						def DH = project.getDependencies()
						module.subprojects { Project p ->
							HashMap<String,Object> hm = new HashMap();
							hm.put("path", p.getPath());
							Dependency d = DH.project(hm)
							if ( d == null ) {
								println "[ERROR] during dependency adding ..."
							}
						}
						println "Multiple module detected in " + modPath + ", I don't know which to choose ..."
					}
                                   }


				}
			}
	           }
		}
	}
}


/**
 * Relative include for subprojects
 */
def implementationR(path) {
        def parent = project.getParent()
        def modsRoot = ""
        if ( parent != null ) {
                modsRoot = parent.getPath()
        }
        def p = modsRoot + path
        debug("modsRoot=" + modsRoot + ", path=" + path + ",p=" + p)
        dependencies {
                implementation project(path: p)
        }
}

project.ext.set("implementationR",{ String path ->
	implementationR(path)
})


