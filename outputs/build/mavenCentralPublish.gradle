def p(msg) {
	def debug = System.env.DEBUG
	if ( debug ) {
		println msg
	}
}

// deduce the remaining part from an entry object
def getRemainingPart(dir) {
  def remainPart = ""
  def projectDirectory = getProjectPath(dir)
  def rootProjectDirectory = rootDir.getPath()
  remainPart = projectDirectory.replace(rootProjectDirectory,"")
  remainPart = remainPart.replaceAll("/",":")
  return remainPart
}

def getProjectPath(obj) {
  if ( obj instanceof Project ) {
    return obj.projectDir.getPath()
  }
  if ( obj instanceof File ) {
      return obj.getPath()
  }
  return obj	
}

// produce project path from the moduleString
def moduleToProject(moduleString) {
  def trgGroup = "io.github.ReleaseStandard.CodeEditor"
  def parts = moduleString.split(":")
  def group = parts[0]
  def module = parts[1]
  def version = parts[2]
  def remainPart = group.replace(trgGroup,"")
  remainPart = remainPart.replace(".",":")
  def path = remainPart + ":${module}"
  return path
}

// BEGIN mavenCentralPublish.gradle
//
// Configure mavenCentral publication
//
apply plugin: 'maven'
apply plugin: 'signing'

def Properties properties = new Properties()
if ( (new File('local.properties')).exists() ) {
	properties.load(project.file("local.properties").newDataInputStream())
}
ext['githubOwner'] = "ReleaseStandard"
ext['githubOwnerEmail'] = "releasestandard@netc.eu"
ext['githubOwnerName'] = "Release Standard"
for(Map.Entry<String, String> e : new HashMap(){{
	put("keyId", "KEYID");
	put("password", "PASSWORD");
	put("key", "KEY");
	put("ossrhUsername", "OSSRH_USERNAME");
	put("ossrhPassword", "OSSRH_PASSWORD");
	put("sonatypeStagingProfileId", "SONATYPE_STAGING_PROFILE_ID");
}}) {
	String k = e.getKey();
	String v = e.getValue();
	ext[k] = properties.getProperty(k)
	if ( System.getenv(v) != null ) {
		ext[k] = System.getenv(v);
	}

	// github CI seem to initialize environment variables to empty string instead of null
        if ( ext[k] != null && ext[k].equals("") ) {
                ext[k] = null;
        }
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    //from javadoc
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    //from sourceSets.main.allSource
}

//
// Maven publish customization and publish
//
def isRoot = ( rootProject.compareTo(project) == 0 ) 
if ( isRoot ) {
	apply plugin: 'io.github.gradle-nexus.publish-plugin'
 
	nexusPublishing {
	        repositories {
	                sonatype {
	                        stagingProfileId = sonatypeStagingProfileId
	                        username = ossrhUsername
	                        password = ossrhPassword
	                        nexusUrl.set(uri("https://s01.oss.sonatype.org/service/local/"))
	                        snapshotRepositoryUrl.set(uri("https://s01.oss.sonatype.org/content/repositories/snapshots/"))
	                }
	        }
	}
}

def thisProject = project

def listTasksOfProject(p) {
	for(Task t : p.tasks) { print "${t.name} " }
}
def getPublicationTaskName(module) {
	return "sign${module}Publication"
}
def producePublicationTaskName(obj) {
	def path = obj
	if ( obj instanceof Project ) {
		path = obj.getPath()
	}
	def result = ""
	for(String p1 : path.split(":")) {
		for(String p2 : p1.split("-")) {
			result += p2.capitalize()
		}
	}
	return result
}
apply plugin: 'maven-publish'
allprojects { Project p -> 
	p.afterEvaluate {
		if ( System.env.DEBUG ) {
			println ""
			println ""
			println "****************************************************"
			println "thisProject=${thisProject.name},p=${p.name}"
		}

		if (  ! ( p.plugins.hasPlugin('com.android.library') 
			|| p.plugins.hasPlugin('java-library') ) ) {
			println "[WARNING] $p cannot be published to MavenCentral"
			return
		}

		def pubname = producePublicationTaskName(p)
		try {
			p.tasks.getByName(getPublicationTaskName("${pubname}"))
			println "task " + getPublicationTaskName("${pubname}") + " found for the project ${thisProject.name}"
		} catch (Exception exception) {
			thisProject.publishing {
				publications {
					"${pubname}"(MavenPublication) {
						artifact sourcesJar
						artifact javadocJar

						if ( p.plugins.hasPlugin('com.android.library') ) {
							p.afterEvaluate {
								from p.components.release
							}
						} else if ( p.plugins.hasPlugin('java-library') ) {
							p.afterEvaluate {
								from p.components.java
							}
						}

						def artifactGroup = "io.github.${githubOwner}.CodeEditor"
						if ( thisProject != p ) {
							artifactGroup += ".${thisProject.name.replace('CodeEditor-', '')}"
						}
						def pname = p.name.replace("CodeEditor-","")
						pom {
							groupId = artifactGroup
							artifactId = pname
							name = pname
							packaging = 'aar'
							description = "${pname} for CodeEditor"
							url = "https://github.com/${githubOwner}/${p.name}"
							scm {
							       connection = "scm:git:github.com/${githubOwner}/${p.name}.git"
							       developerConnection = "scm:git:ssh://github.com/${githubOwner}/${p.name}.git"
							       url = "https://github.com/${githubOwner}/${p.name}"
							}
							developers {
							       developer {
							               id = "${githubOwner}"
							               name = "${githubOwnerName}"
							               email = "${githubOwnerEmail}"
							       }
							}
							licenses {
							       license {
							               name = "The Apache License, Version 2.0"
							               url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
							       }
							}
						}
					}
				}
				thisProject.signing {
				        useInMemoryPgpKeys(
				                keyId,
			        	        key,
			                	password,
				        )
				        sign thisProject.publishing.publications."${pubname}"
				}
				if ( System.env.DEBUG ) {
					println "mavenCentralPublish: register " + getPublicationTaskName("${pubname}") + " on $thisProject"
				}
				try {
					// Make that signature task is executed after the reBundleAarRelease //
					def t = thisProject.tasks.getByName(getPublicationTaskName("${pubname}"))
					p.afterEvaluate {
						if ( p.plugins.hasPlugin("com.kezong.fat-aar") ) {
							Task ta = null
							try {
								ta = p.tasks.getByName("reBundleAarRelease")
							} catch(Exception e) {}
							if ( ta != null ) {
								t.mustRunAfter ta
							}
						}
					}
				} catch(Exception e) { println "[WARNING] could not provide signature for ${p.name}" }
			}
		}
	}
}
