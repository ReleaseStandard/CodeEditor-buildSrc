def p(msg) {
	def debug = System.env.DEBUG
	if ( debug ) {
		println msg
	}
}

// deduce the remaining part from an entry object
def getRemainingPart(dir) {
  def remainPart = ""
  def projectDirectory = getProjectPath(dir)
  def rootProjectDirectory = rootDir.getPath()
  remainPart = projectDirectory.replace(rootProjectDirectory,"")
  remainPart = remainPart.replaceAll("/",":")
  return remainPart
}

def getProjectPath(obj) {
  if ( obj instanceof Project ) {
    return obj.projectDir.getPath()
  }
  if ( obj instanceof File ) {
      return obj.getPath()
  }
  return obj	
}

// produce project path from the moduleString
def moduleToProject(moduleString) {
  def trgGroup = "io.github.ReleaseStandard.CodeEditor"
  def parts = moduleString.split(":")
  def group = parts[0]
  def module = parts[1]
  def version = parts[2]
  def remainPart = group.replace(trgGroup,"")
  remainPart = remainPart.replace(".",":")
  def path = remainPart + ":${module}"
  return path
}

def prefix(msg) {
	return "[TEST]" + msg
}
def info(msg) {
	project.logger.info(prefix(msg))
}
def debug(msg) {
	project.logger.debug(prefix(msg))
}

info("Script inclusion")

/**
 * Relative include for subprojects
 */
def resolveRelativePath(path) {
	def remainPart = getRemainingPart(project)
        String[] parts = remainPart.split(":")
        String finalPath = ""
        for(int a = 0; a < parts.length-1; a=a+1) {
        	if(parts[a].size() > 0 ) {
        		finalPath += ":" + parts[a]
        	}
        }
        finalPath += path
	def p = project.findProject(finalPath)
	if ( p != null ) {
        	if ( System.env.DEBUG ) { println "resolveRelativePath: finalPath=${finalPath},remainPart=${remainPart},path=${path}" }
        	return finalPath
        } else {
	        String alternativePath = remainPart + path
        	p = project.findProject(alternativePath)
        	if ( p != null ) {
	        	if ( System.env.DEBUG ) { println "resolveRelativePath: alternativePath=${alternativePath},path=${path}" }
	        	return alternativePath
        	}
        }
        println "[WARNING] : path resolution has failed"
        return null
}
def implementationR(path) {

        def finalPath = resolveRelativePath(path)
        if ( System.env.DEBUG ) {
        	println "implementationR : finalPath=${finalPath}"
        }
        dependencies {
                universalEmbed project(path: finalPath)
        }
}


project.ext.set("implementationR",{ String path ->
        implementationR(path)
})


configurations {
	all {
		resolutionStrategy {
			dependencySubstitution.all { DependencySubstitution dependency ->
       if ( requested instanceof ProjectComponentSelector ) {
         info("This is a project dependencies")
       }
       else if ( requested instanceof ModuleComponentSelector ) {
					if ( rootProject.hasProperty('buildFromLocal') ) {

						// tweak remote dependencie resolution
						def trgGroup = "io.github.ReleaseStandard.CodeEditor"
						if ( requested.group.matches("${trgGroup}.*") ) {
							def path = moduleToProject(requested.getDisplayName())
							def prj = rootProject.findProject(path)

							// TODO : need to ensure that the assemble has runned on the subproject before useTarget
							// you must dependends on this build
							//def tAssemble = prj.tasks.getByName("assemble")

							dependency.useTarget prj
						}

					}
				}
			}
		}
	}
}

