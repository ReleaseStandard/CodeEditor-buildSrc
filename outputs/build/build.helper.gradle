ext['githubOwner'] = "ReleaseStandard"
ext['groupPathBase'] = "io.github.${githubOwner}.CodeEditor"

def p(msg) {
	def debug = System.env.DEBUG
	if ( debug ) {
		println msg
	}
}

// deduce the remaining part from an entry object
def getRemainingPart(dir) {
  def remainPart = ""
  def projectDirectory = getProjectPath(dir)
  def rootProjectDirectory = rootDir.getPath()
  remainPart = projectDirectory.replace(rootProjectDirectory,"")
  remainPart = remainPart.replaceAll("/",":")
  return remainPart
}

def getProjectPath(obj) {
  if ( obj instanceof Project ) {
    return obj.projectDir.getPath()
  }
  if ( obj instanceof File ) {
      return obj.getPath()
  }
  return obj	
}

// produce project path from the moduleString
def moduleToProject(moduleString) {
  def parts = moduleString.split(":")
  def group = parts[0]
  def module = parts[1]
  def version = parts[2]
  def remainPart = group.replace("${groupPathBase}","")
  remainPart = remainPart.replace(".",":")
  def path = remainPart + ":${module}"
  return path
}

// BEGIN build.helper.gradle
//
// - implementation relative for projects
// - change remote to local when property buildFromLocal is set
//
def prefix(msg) {
	return "[TEST]" + msg
}
def info(msg) {
	project.logger.info(prefix(msg))
}
def debug(msg) {
	project.logger.debug(prefix(msg))
}

info("Script inclusion")

/**
 * Relative include for subprojects
 */
def resolveRelativePath(path) {
	def remainPart = getRemainingPart(project)
	String[] parts = remainPart.split(":")
	String finalPath = ""
	for(int a = 0; a < parts.length-1; a=a+1) {
		if(parts[a].size() > 0 ) {
			finalPath += ":" + parts[a]
		}
	}
	finalPath += path
	def p = project.findProject(finalPath)
	if ( p != null ) {
		if ( System.env.DEBUG ) { println "resolveRelativePath: finalPath=${finalPath},remainPart=${remainPart},path=${path}" }
		return finalPath
	} else {
		String alternativePath = remainPart + path
		p = project.findProject(alternativePath)
		if ( p != null ) {
			if ( System.env.DEBUG ) { println "resolveRelativePath: alternativePath=${alternativePath},path=${path}" }
			return alternativePath
		}
	}
	throw new RuntimeException("project with path '${path}' not found")
}

/**
 * This extends project() function by making it relative.
 * @param path
 * @return
 */
def projectR(path) {
	def resolvedPath = resolveRelativePath(path)
	p "projectR : resolvedPath = ${resolvedPath}"
	return project(resolvedPath)
}

project.ext.set("projectR",{ String path ->
	projectR(path)
})

if ( rootProject.hasProperty('buildFromLocal') ) {
	configurations {
		all {
			resolutionStrategy {
				dependencySubstitution.all { DependencySubstitution dependency ->
					if ( requested instanceof ProjectComponentSelector ) {
						// do nothing
						System.err.println("trying to resolve : ${requested}")
					}
					else if ( requested instanceof ModuleComponentSelector )
					{
						// tweak remote dependencie resolution
						if ( requested.group.matches("${groupPath}.*") ) {
							def path = moduleToProject(requested.getDisplayName())
							def prj = rootProject.findProject(path)
							for(Task t : project.tasks) {
								if ( t.getName().equals("projects") || t.getName().equals("tasks") ) { continue }
								try {
									def rootAssemble = t
									def childAssemble = prj.tasks.getByName(t.getName())
									rootAssemble.dependsOn childAssemble
									rootAssemble.mustRunAfter childAssemble
								} catch(Exception e) {}
							}
							def explain = "Substitute ${requested.getDisplayName()} to ${prj} because we test"
							if ( System.env.DEBUG ) {
								println "DependencySubstitution: ${explain}"
							}
							dependency.useTarget(prj, "${explain}")
						}
					}
				}
			}
		}
	}
}

// END
