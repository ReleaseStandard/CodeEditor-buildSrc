ext['githubOwner'] = "ReleaseStandard"
ext['groupPathBase'] = "io.github.${githubOwner}.CodeEditor"

def p(msg) {
	def debug = System.env.DEBUG
	if ( debug ) {
		println msg
	}
}

// deduce the remaining part from an entry object
def getRemainingPart(dir) {
  def remainPart = ""
  def projectDirectory = getProjectPath(dir)
  def rootProjectDirectory = rootDir.getPath()
  remainPart = projectDirectory.replace(rootProjectDirectory,"")
  remainPart = remainPart.replaceAll("/",":")
  return remainPart
}

def getProjectPath(obj) {
  if ( obj instanceof Project ) {
    return obj.projectDir.getPath()
  }
  if ( obj instanceof File ) {
      return obj.getPath()
  }
  return obj	
}

// produce project path from the moduleString
def moduleToProject(moduleString) {
  def parts = moduleString.split(":")
  def group = parts[0]
  def module = parts[1]
  def version = parts[2]
  def remainPart = group.replace("${groupPathBase}","")
  remainPart = remainPart.replace(".",":")
  def path = remainPart + ":${module}"
  return path
}

// Tweak the dependency resolution mecanism to load projects from the load instead of remote when possible

// delegate pattern to redirect remote dependencies on local ones
class ModuleComponentSelectorDelegate implements ModuleComponentSelector {

	class VersionConstraintDelegate implements VersionConstraint {
		final VersionConstraint delegate;

		public VersionConstraintDelegate(VersionConstraint o) {
			this.delegate = o;
		}

		@Override
		String getBranch() {
			return delegate.getBranch()
		}

		@Override
		String getRequiredVersion() {
			return ""
		}

		@Override
		String getPreferredVersion() {
			return delegate.getPreferredVersion()
		}

		@Override
		String getStrictVersion() {
			return delegate.getStrictVersion()
		}

		@Override
		List<String> getRejectedVersions() {
			return delegate.getRejectedVersions()
		}

		@Override
		String getDisplayName() {
			return delegate.getDisplayName()
		}
	}

	final ModuleComponentSelector delegate;

	public ModuleComponentSelectorDelegate(ModuleComponentSelector o) {
		this.delegate = o;
	}
	@Override
	String getGroup() {
		delegate.getGroup();
	}

	@Override
	String getModule() {
		return delegate.getModule()
	}

	@Override
	String getVersion() {
		return ""
	}

	@Override
	VersionConstraint getVersionConstraint() {
		return new VersionConstraintDelegate(delegate.getVersionConstraint())
	}

	@Override
	ModuleIdentifier getModuleIdentifier() {
		return delegate.getModuleIdentifier()
	}

	@Override
	String getDisplayName() {
		return delegate.getDisplayName()
	}

	@Override
	boolean matchesStrictly(ComponentIdentifier componentIdentifier) {
		return delegate.matchesStrictly(componentIdentifier)
	}

	@Override
	AttributeContainer getAttributes() {
		return delegate.getAttributes()
	}

	@Override
	List<Capability> getRequestedCapabilities() {
		return delegate.getRequestedCapabilities()
	}
}

if ( rootProject.hasProperty("buildFromLocal") ) {
	configurations {
		all {
			resolutionStrategy {
				dependencySubstitution.all { DependencySubstitution dependency ->
					if (requested instanceof ProjectComponentSelector) {
						// do nothing
					} else if (requested instanceof ModuleComponentSelector) {
						// tweak remote dependencie resolution
						if (requested.group.matches("${groupPathBase}.*")) {
							p("Resolving ${requested} to local artifact")
							dependency.useTarget(new ModuleComponentSelectorDelegate(requested))
						}
					}
				}
			}
		}
	}
}