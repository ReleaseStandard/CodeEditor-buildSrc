ext['githubOwner'] = "ReleaseStandard"
ext['groupPathBase'] = "io.github.${githubOwner}.CodeEditor"

def p(msg) {
	def debug = System.env.DEBUG
	if ( debug ) {
		println msg
	}
}

// deduce the remaining part from an entry object
def getRemainingPart(dir) {
  def remainPart = ""
  def projectDirectory = getProjectPath(dir)
  def rootProjectDirectory = rootDir.getPath()
  remainPart = projectDirectory.replace(rootProjectDirectory,"")
  remainPart = remainPart.replaceAll("/",":")
  return remainPart
}

def getProjectPath(obj) {
  if ( obj instanceof Project ) {
    return obj.projectDir.getPath()
  }
  if ( obj instanceof File ) {
      return obj.getPath()
  }
  return obj	
}

// produce project path from the moduleString
def moduleToProject(moduleString) {
  def parts = moduleString.split(":")
  def group = parts[0]
  def module = parts[1]
  def version = parts[2]
  def remainPart = group.replace("${groupPathBase}","")
  remainPart = remainPart.replace(".",":")
  def path = remainPart + ":${module}"
  return path
}

// Tweak the dependency resolution mecanism to load projects from the load instead of remote when possible

p("Script inclusion")

configurations {
	all {
		resolutionStrategy {
			dependencySubstitution.all { DependencySubstitution dependency ->
				if ( requested instanceof ProjectComponentSelector ) {
					// do nothing
				}
				else if ( requested instanceof ModuleComponentSelector )
				{
					p("${project} trying to resolve : ${requested} : ${requested.group} : ${groupPathBase}")
					// tweak remote dependencie resolution
					if ( requested.group.matches("${groupPathBase}.*") ) {
						def path = "${requested.displayName}".replaceFirst("${groupPathBase}","").replaceAll("\\.", ":")
						p("path=${path}")
						def prj = rootProject.findProject(path)
						if ( prj != null ) {
							p("Substitute ${requested.getDisplayName()} to ${prj} because we test")
							dependency.useTarget(prj, "${explain}")
						}
					}
				}
			}
		}
	}
}