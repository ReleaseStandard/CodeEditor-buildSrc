ext['githubOwner'] = "ReleaseStandard"
ext['groupPathBase'] = "io.github.${githubOwner}.CodeEditor"

def p(msg) {
	def debug = System.env.DEBUG
	if ( debug ) {
		println msg
	}
}

// deduce the remaining part from an entry object
def getRemainingPart(dir) {
  def remainPart = ""
  def projectDirectory = getProjectPath(dir)
  def rootProjectDirectory = rootDir.getPath()
  remainPart = projectDirectory.replace(rootProjectDirectory,"")
  remainPart = remainPart.replaceAll("/",":")
  return remainPart
}

def getProjectPath(obj) {
  if ( obj instanceof Project ) {
    return obj.projectDir.getPath()
  }
  if ( obj instanceof File ) {
      return obj.getPath()
  }
  return obj	
}

// produce project path from the moduleString
def moduleToProject(moduleString) {
  def parts = moduleString.split(":")
  def group = parts[0]
  def module = parts[1]
  def version = parts[2]
  def remainPart = group.replace("${groupPathBase}","")
  remainPart = remainPart.replace(".",":")
  def path = remainPart + ":${module}"
  return path
}

// BEGIN packaging.gradle
//
// It is up to the module to support zero or more views (if no view given : a java library is maid)
//  - embed all projects into the main
//  - list supported views
//  - change the packaging mode (from what view has been choosed)

def vtype = ""
ext["VIEW_PREFIX"] = "view-"
import org.apache.tools.ant.DirectoryScanner
import org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency

// list view supported by this project
def getSupportedViews() {
	DirectoryScanner scanner = new DirectoryScanner();
	String [] patterns = ["${VIEW_PREFIX}*"] as String[];
	scanner.setIncludes(patterns);
	scanner.setBasedir(project.projectDir.getPath());
	scanner.setCaseSensitive(true);
	scanner.scan();
	return scanner.dirsIncluded
}
// test a given object to see if it represent a view
def isAview(p) {
	return ( p.name.contains(VIEW_PREFIX) )
}

// try to guess view type for this module
if ( System.env.VIEW_TYPE ) {
	vtype = System.env.VIEW_TYPE
} else {
	String [] files = getSupportedViews()
	if ( files.length > 1 ) {
		vtype="android"
		def msg="[WARNING] This project is compatible with different views, please specify one with VIEW_TYPE env"
		println msg
		println "Choosing android ..."
	} else if (files.length == 1) {
		vtype = files[0]
	} else {
		println "[WARNING] GUESS FAIL: No views for $project"
	}
}
vtype=vtype.replaceFirst(VIEW_PREFIX,"")

task listSupportedViews() {
	doFirst() {
		println "view supported by this project:"
		for(String f : getSupportedViews()) {
			String viewName = f.replace("${VIEW_PREFIX}","")
			println " - ${viewName}"
		}
	}
}
def javaVersion = JavaVersion.VERSION_1_8
def viewFile = "${project.projectDir.getPath()}/${VIEW_PREFIX}${vtype}"
if ( (new File(viewFile)).exists() ) {
	def folder = "${VIEW_PREFIX}${vtype}"
	apply from: "${folder}/build.gradle"
	if ( vtype.equals("android") ) {
		android.sourceSets {
			main {
				manifest.srcFile "${folder}/src/main/AndroidManifest.xml"
				java.srcDirs = ["${folder}/src/main/java"]
				res.srcDirs = ["${folder}/src/main/res"]
			}
		}
		android.packagingOptions {
			exclude "**/module-info.class"
		}
		android.compileOptions {
			sourceCompatibility javaVersion
			targetCompatibility javaVersion
		}
		android.defaultConfig.versionCode semver.minor
		android.defaultConfig.versionName "${version}"
		java {
			sourceCompatibility = javaVersion
			targetCompatibility = javaVersion
		}
	} else if ( vtype.equals("terminal") ) {
		println "Configure additionnal properties here ..."
		sourceSets {
			main {
				java {
					srcDirs 'view-terminal/src/main/java'
				}
			}
		}
	}
} else {
	apply plugin: 'java-library'
}

// include all subprojects into this node project
for (Project prj : subprojects) {
	p("found subprojects : ${prj}")
	if (!isAview(prj)) {
		p("embed ${prj} into ${project}")
		dependencies.universalEmbed prj
	}
}

// link tasks that need to be
afterEvaluate {
	configurations.all { Configuration c ->
		c.dependencies.all { Dependency dependency ->
			if (dependency instanceof DefaultProjectDependency) {
				Project targetProject = dependency.dependencyProject
				if ( targetProject != project ) {
					p "resolve dependency : ${dependency} for ${project}($c)"
					Object[] taskTypes = [SourceTask.class, Delete.class, AbstractTestTask.class, Test.class, "test"]
					for(Object taskType : taskTypes) {
						Object collection
						if ( taskType instanceof Class ) {
							collection = tasks.withType(taskType)
						} else if ( taskType instanceof String ) {
							collection = tasks.getByName(taskType)
						} else {
							println "Error unreconized type for taskType " + taskType.getClass()
							System.exit(1)
						}

						for (Task rootTask : collection) {
							Task childTask = targetProject.tasks.findByName(rootTask.getName())
							if (childTask == null) {
								continue;
							}
							rootTask.dependsOn childTask
							rootTask.mustRunAfter childTask
						}
					}
				}
			}
		}
	}
}

// END
